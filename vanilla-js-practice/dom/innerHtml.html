<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      p {
        font-weight: 500;
      }
    </style>
  </head>
  <body>
    <h2>innerHTML</h2>
    <p>
      요소 노드의 innerHTML 프로퍼티를 참조하면 요소 노드의 콘텐츠 영역(시작
      태그와 종료 태그 사이) 내에 포함된 모든 HTML 마크업을 문자열로 반환한다.
      요소 노드의 innerHTML 프로퍼티에 문자열을 할당하면 요소 노드의 모든 자식
      노드가 제거되고 할당한 문자열에 포함되어 있는 HTML 마크업이 파싱되어 요소
      노드의 자식 노드로 DOM에 반영된다.
    </p>
    <div id="foo">Hello <span>world!</span></div>
    <hr />
    <h2>innerHTML을 이용한 dom 조작</h2>
    <ul id="fruits">
      <li class="apple">Apple</li>
    </ul>
    <p>
      위 예제는 #fruits 요소에 자식 요소 li.banana를 추가한다. 이때 #fruits
      요소의 자식 요소 li.apple은 아무런 변경이 없으므로 다시 생성할 필요가
      없다. 다만 새롭게 추가할 li.banana 요소 노드만 생성하여 #fruits 요소의
      자식 요소로 추가하면 된다. 위 예제를 얼핏 보면 그렇게 동작할 것처럼
      보이지만 사실은 #fruits 요소의 모든 자식 노드(li.apple)를 제거하고 새롭게
      요소 노드 li.apple와 li.banana를 생성하여 #fruits 요소의 자식 요소로
      추가한다.
    </p>
  </body>
  <script>
    // #foo 요소의 콘텐츠 영역 내의 HTML 마크업을 문자열로 취득한다.
    console.log(document.getElementById("foo").innerHTML);
    // "Hello <span>world!</span>"

    const $fruits = document.getElementById("fruits");
    console.log($fruits);
    // 노드 추가
    $fruits.innerHTML += '<li class="banana">Banana</li>';
    console.log($fruits);

    // 노드 교체
    // $fruits.innerHTML = '<li class="orange">Orange</li>';

    // 노드 삭제
    // $fruits.innerHTML = "";

    console.log($fruits);
  </script>
</html>
